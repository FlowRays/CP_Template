{
    "bit": {
        "prefix": "bit",
        "body": [
            "template<typename T>",
            "struct Fenwick{",
            "    int n;",
            "    vector<T> tr;",
            "",
            "    Fenwick(int n) : n(n), tr(n + 1, 0){}",
            "",
            "    int lowbit(int x){",
            "        return x & -x;",
            "    }",
            "",
            "    void modify(int x, T c){",
            "        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;",
            "    }",
            "",
            "    void modify(int l, int r, T c){",
            "        modify(l, c);",
            "        if (r + 1 <= n) modify(r + 1, -c);",
            "    }",
            "",
            "    T query(int x){",
            "        T res = T();",
            "        for(int i = x; i; i -= lowbit(i)) res += tr[i];",
            "        return res;",
            "    }",
            "",
            "    T query(int l, int r){",
            "        return query(r) - query(l - 1);",
            "    }",
            "",
            "    int find_first(T sum){",
            "        int ans = 0; T val = 0;",
            "        for(int i = __lg(n); i >= 0; i--){",
            "            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum){",
            "                ans |= 1 << i;",
            "                val += tr[ans | (1 << i)];",
            "            }",
            "        }",
            "        return ans + 1;",
            "    }",
            "",
            "    int find_last(T sum){",
            "        int ans = 0; T val = 0;",
            "        for(int i = __lg(n); i >= 0; i--){",
            "            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum){",
            "                ans |= 1 << i;",
            "                val += tr[ans | (1 << i)];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "",
            "};",
            "using BIT = Fenwick<int>;",
            ""
        ],
        "description": "bit"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "function<void(int,int)> dfs = [&](int u,int fa) {",
            "    for(auto v: e[u]) {",
            "        if(v == fa) continue;",
            "        dfs(v,u);",
            "        $0",
            "    }",
            "};",
            ""
        ],
        "description": "dfs"
    },
    "dfs_f": {
        "prefix": "dfs_f",
        "body": [
            "function<void(int)> dfs = [&](int u) {",
            "    for(auto v: e[u]) {",
            "        dfs(v);",
            "        $0",
            "    }",
            "};",
            ""
        ],
        "description": "dfs_f"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "priority_queue<pii> q;",
            "q.emplace(0,s);",
            "vi d(n+1,-1);",
            "while(q.size()) {",
            "    auto [dis,u] = q.top();",
            "    q.pop();",
            "    if(d[u] != -1) continue;",
            "    d[u] = -dis;",
            "    for(auto [v,w]: e[u]) {",
            "        q.emplace(dis-w,v);",
            "    }",
            "}",
            ""
        ],
        "description": "dijkstra"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "struct DSU {",
            "    vi f, sz;",
            "",
            "    DSU(int n): f(n+1), sz(n+1,1) {",
            "        iota(all(f), 0);",
            "    }",
            "",
            "    int find(int x) {",
            "        return x == f[x] ? x : f[x] = find(f[x]);",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    bool merge(int x,int y) {",
            "        x = find(x), y = find(y);",
            "        if(x == y) return false;",
            "        sz[x] += sz[y];",
            "        f[y] = x;",
            "        return true;",
            "    }",
            "",
            "    int size(int x) {",
            "        return sz[find(x)];",
            "    }",
            "};",
            ""
        ],
        "description": "dsu"
    },
    "dsu_w": {
        "prefix": "dsu_w",
        "body": [
            "template<typename T>",
            "struct DSU{",
            "    vi f;",
            "    vector<T> d;",
            "    DSU(int n): f(n+1), d(n+1) {",
            "        iota(all(f), 0);",
            "    }",
            "",
            "    int find(int x) {",
            "        if(f[x] != x){",
            "            int rt = find(f[x]);",
            "            d[x] += d[f[x]];",
            "            f[x] = rt;",
            "        }",
            "        return f[x];",
            "    }",
            "",
            "    T get(int x, int y) {",
            "        return d[x] - d[y];",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    bool merge(int x, int y, T v) {",
            "        int fx = find(x), fy = find(y);",
            "        if (fx == fy) return false;",
            "        d[fx] = v - d[x] + d[y];",
            "        f[fx] = fy;",
            "        return true;",
            "    }",
            "};",
            ""
        ],
        "description": "dsu_w"
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "struct Graph {",
            "    int n,tot;",
            "    vi in,out;",
            "    vii e;",
            "",
            "    Graph() {}",
            "",
            "    Graph(int n): n(n),tot(n),in(n*4+1),out(n*4+1),e(n*7+1) {",
            "        build(1,1,n);",
            "    }",
            "",
            "    inline void add(int u,int v) {",
            "        e[u].pb(v);",
            "    }",
            "",
            "    void build(int u,int l,int r) {",
            "        if(l == r) {",
            "            in[u] = l;",
            "            out[u] = l;",
            "        } else {",
            "            in[u] = ++tot, out[u] = ++tot;",
            "            int mid = l+r >> 1;",
            "            build(u<<1,l,mid), build(u<<1|1,mid+1,r);",
            "            add(in[u],in[u<<1]);",
            "            add(in[u],in[u<<1|1]);",
            "            add(out[u<<1],out[u]);",
            "            add(out[u<<1|1],out[u]);",
            "        }",
            "    }",
            "",
            "    void upd(int u,int l,int r,int x,int y,int k) {",
            "        if(x<=l && r<=y) {",
            "            // add: id[u]",
            "        } else {",
            "            int mid = l+r >> 1;",
            "            if(x<=mid) upd(u<<1,l,mid,x,y,k);",
            "            if(y>mid) upd(u<<1|1,mid+1,r,x,y,k);",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "graph"
    },
    "hash": {
        "prefix": "hash",
        "body": [
            "uniform_int_distribution<ll> dist(0.25*mod, 0.75*mod);",
            "const ll mod1 = 1e9+7;",
            "const ll mod2 = 1e9+9;",
            "const ll k1 = dist(rng);",
            "const ll k2 = dist(rng);",
            "",
            "struct Hash {",
            "    vi h1, h2, b1, b2;",
            "    vi s;",
            "    ll n;",
            "",
            "    Hash(vi ss) {",
            "        n = ss.size()-1;",
            "        s = ss;",
            "        h1.resize(n+1), h2.resize(n+1);",
            "        b1.resize(n+1), b2.resize(n+1);",
            "        b1[0] = b2[0] = 1;",
            "        fore(i,1,n) {",
            "            b1[i] = b1[i-1]*k1%mod1;",
            "            h1[i] = (h1[i-1]*k1+s[i])%mod1;",
            "            b2[i] = b2[i-1]*k2%mod2;",
            "            h2[i] = (h2[i-1]*k2+s[i])%mod2;",
            "        }",
            "    }",
            "",
            "    pii get(ll l,ll r) {",
            "        ll t1 = ((h1[r]-h1[l-1]*b1[r-l+1])%mod1+mod1)%mod1;",
            "        ll t2 = ((h2[r]-h2[l-1]*b2[r-l+1])%mod2+mod2)%mod2;",
            "        return make_pair(t1,t2);",
            "    }",
            "};",
            ""
        ],
        "description": "hash"
    },
    "hld": {
        "prefix": "hld",
        "body": [
            "struct HLD {",
            "    int n,idx;",
            "    vii e;",
            "    vi sz,fa,dep,hs,top,l,r,id;",
            "",
            "    HLD() {}",
            "",
            "    HLD(int n) {",
            "        init(n);",
            "    }",
            "",
            "    void init(int n) {",
            "        this->n = n, idx = 0;",
            "        e.assign(n+1,{});",
            "        sz.resize(n+1);",
            "        fa.resize(n+1);",
            "        dep.resize(n+1);",
            "        hs.assign(n+1,0);",
            "        top.resize(n+1);",
            "        l.resize(n+1);",
            "        r.resize(n+1);",
            "        id.resize(n+1);",
            "    }",
            "",
            "    void add(int u,int v) {",
            "        e[u].pb(v);",
            "        e[v].pb(u);",
            "    }",
            "",
            "    void work(int root = 1) {",
            "        dfs1(root,0);",
            "        dfs2(root,root);",
            "    }",
            "",
            "    void dfs1(int u,int f) {",
            "        sz[u] = 1;",
            "        fa[u] = f;",
            "        dep[u] = dep[f]+1;",
            "        for(auto v: e[u]) {",
            "            if(v == f) continue;",
            "            dfs1(v,u);",
            "            sz[u] += sz[v];",
            "            if(!hs[u] || sz[v] > sz[hs[u]]) hs[u] = v;",
            "        }",
            "    }",
            "",
            "    void dfs2(int u,int t) {",
            "        top[u] = t;",
            "        l[u] = ++idx;",
            "        id[idx] = u;",
            "        if(hs[u]) dfs2(hs[u],t);",
            "        for(auto v: e[u]) {",
            "            if(v == hs[u] || v == fa[u]) continue;",
            "            dfs2(v,v);",
            "        }",
            "        r[u] = idx;",
            "    }",
            "",
            "    vector<pii> get_path(int u,int v) {",
            "        vector<pii> res;",
            "        while(top[u] != top[v]) {",
            "            if(dep[top[u]] < dep[top[v]]) swap(u,v);",
            "            res.eb(l[top[u]],l[u]);",
            "            u = fa[top[u]];",
            "        }",
            "        if(dep[u] < dep[v]) swap(u,v);",
            "        res.eb(l[v],l[u]);",
            "        return res;",
            "    }",
            "",
            "    int lca(int u,int v) {",
            "        while(top[u] != top[v]) {",
            "            if(dep[top[u]] < dep[top[v]]) v = fa[top[v]];",
            "            else u = fa[top[u]];",
            "        }",
            "        return dep[u] < dep[v] ? u : v; ",
            "    }",
            "",
            "    int dist(int u, int v) {",
            "        return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
            "    }",
            "",
            "    int jump(int u, int k) {",
            "        if(dep[u] < k) return -1;",
            "        int d = dep[u] - k;",
            "        while(dep[top[u]] > d) u = fa[top[u]];",
            "        return id[l[u]-dep[u]+d];",
            "    }",
            "    ",
            "    bool isAncester(int u, int v) {",
            "        return l[u] <= l[v] && r[v] <= r[u];",
            "    }",
            "",
            "    // example",
            "    void modify(int u,int v,int k) {",
            "        while(top[u] != top[v]) {",
            "            if(dep[top[u]] < dep[top[v]]) swap(u,v);",
            "            // seg.modify(l[top[u]],l[u],{k});",
            "            u = fa[top[u]];",
            "        }",
            "        if(dep[u] < dep[v]) swap(u,v);",
            "        // seg.modify(l[v],l[u],{k});",
            "    }",
            "",
            "    // example",
            "    int query(int u,int v) {",
            "        int res = 0;",
            "        while(top[u] != top[v]) {",
            "            if(dep[top[u]] < dep[top[v]]) swap(u,v);",
            "            // res += seg.query(l[top[u]],l[u]).s;",
            "            u = fa[top[u]];",
            "        }",
            "        if(dep[u] < dep[v]) swap(u,v);",
            "        // res += seg.query(l[v],l[u]).s;",
            "        return res;",
            "    }",
            "",
            "    pair<vi,ve<pii>> compress(vi v) {",
            "        auto cmp = [&](int a, int b) { return l[a] < l[b]; };",
            "        sort(all(v),cmp);",
            "        v.erase(unique(all(v)),v.end());",
            "        int k = v.size();",
            "        forn(i,k-1) v.pb(lca(v[i],v[i+1]));",
            "        sort(all(v),cmp);",
            "        v.erase(unique(all(v)),v.end());",
            "        ve<pii> edges;",
            "        vi stk;",
            "        for(auto x: v){",
            "            while(!stk.empty() && r[stk.back()] < l[x]) stk.pop_back();",
            "            if(!stk.empty()) edges.eb(stk.back(),x);",
            "            stk.pb(x);",
            "        }",
            "        return {v, edges};",
            "    }",
            "};",
            ""
        ],
        "description": "hld"
    },
    "linear_basis": {
        "prefix": "lb",
        "body": [
            "template<const int M>",
            "struct LinearBasis {",
            "    array<int,M> a = {};",
            "    array<int,M> t = {};",
            "    int sz = 0;",
            " ",
            "    bool add(int x,int y = inf) {",
            "        for(int i=M-1;i>=0;--i) {",
            "            if(x>>i&1) {",
            "                if(!a[i]) {",
            "                    a[i] = x;",
            "                    t[i] = y;",
            "                    sz++;",
            "                    return true;",
            "                }",
            "                if(y > t[i]) {",
            "                    swap(a[i],x);",
            "                    swap(t[i],y);",
            "                }",
            "                x ^= a[i];",
            "            }",
            "        }",
            "        return false;",
            "    }",
            " ",
            "    void operator+=(const LinearBasis &t) {",
            "        forn(i,M) {",
            "            if(t.a[i]) add(t.a[i],t.t[i]);",
            "        }",
            "    }",
            " ",
            "    LinearBasis operator+(const LinearBasis &a) const {",
            "        auto res = *this;",
            "        res += a;",
            "        return res;",
            "    }",
            " ",
            "    bool query(int x,int y = 0) {",
            "        for(int i=M-1;i>=0;--i) {",
            "            if((x>>i&1) && t[i] >= y) {",
            "                x ^= a[i];",
            "            }",
            "        }",
            "        return x == 0;",
            "    }",
            "",
            "    int qmax(int x = 0,int y = 0) {",
            "        for(int i=M-1;i>=0;--i) {",
            "            if(a[i] && t[i] >= y) x = max(x,x^a[i]);",
            "        }",
            "        return x;",
            "    }",
            "};",
            "using lb = LinearBasis<30>;",
            ""
        ],
        "description": "linear_basis"
    },
    "local": {
        "prefix": "local",
        "body": [
            "freopen(\"data.in\", \"r\", stdin);",
            "freopen(\"data.out\", \"w\", stdout);",
            ""
        ],
        "description": "local"
    },
    "maxflow": {
        "prefix": "maxflow",
        "body": [
            "const int V = 2e4+10;",
            "const int E = 2e5+10;",
            "",
            "template<typename T>",
            "struct MaxFlow {",
            "    struct edge {",
            "        int v,nxt;",
            "        T f;",
            "    } e[E*2];",
            "",
            "    int s,t,vtot;",
            "    int head[V],etot;",
            "    int dis[V],cur[V];",
            "",
            "    void addedge(int u, int v, T f, T vf = 0) {",
            "        e[etot] = {v,head[u],f}; head[u] = etot++;",
            "        e[etot] = {u,head[v],vf}; head[v] = etot++;",
            "    }",
            "",
            "    bool bfs() {",
            "        fore(i,1,vtot) {",
            "            dis[i] = 0;",
            "            cur[i] = head[i];",
            "        }",
            "        queue<int> q;",
            "        q.push(s);",
            "        dis[s] = 1;",
            "        while(q.size()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            for(int i=head[u];~i;i=e[i].nxt) {",
            "                if(e[i].f && !dis[e[i].v]) {",
            "                    int v = e[i].v;",
            "                    dis[v] = dis[u] + 1;",
            "                    if(v == t) return true;",
            "                    q.push(v);",
            "                }",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "",
            "    T dfs(int u, T m) {",
            "        if(u == t) return m;",
            "        T flow = 0;",
            "        for(int i=cur[u];~i;cur[u]=i=e[i].nxt) {",
            "            if(e[i].f && dis[e[i].v] == dis[u] + 1) {",
            "                T f = dfs(e[i].v,min(m,e[i].f));",
            "                e[i].f -= f;",
            "                e[i^1].f += f;",
            "                m -= f;",
            "                flow += f;",
            "                if(!m) break;",
            "            }",
            "        }",
            "        if(!flow) dis[u] = -1;",
            "        return flow;",
            "    }",
            "",
            "    T dinic() {",
            "        T flow = 0;",
            "        while(bfs()) flow += dfs(s,numeric_limits<T>::max());",
            "        return flow;",
            "    }",
            "",
            "    void init(int s_,int t_,int vtot_) {",
            "        s = s_, t = t_, vtot = vtot_;",
            "        etot = 0;",
            "        fore(i,1,vtot) head[i] = -1;",
            "    }",
            "};",
            ""
        ],
        "description": "maxflow"
    },
    "mcmf": {
        "prefix": "mcmf",
        "body": [
            "const int V = 2e4+10;",
            "const int E = 2e5+10;",
            "",
            "template<typename T>",
            "struct MCMF {",
            "    struct edge {",
            "        int v,nxt;",
            "        T f,c;",
            "    } e[E*2];",
            "",
            "    int s,t,vtot;",
            "    int head[V],etot;",
            "    T dis[V],flow,cost;",
            "    int pre[V];",
            "    bool vis[V];",
            "",
            "    void addedge(int u,int v,T f,T c,T vf = 0) {",
            "        e[etot] = {v,head[u],f,c}; head[u] = etot++;",
            "        e[etot] = {u,head[v],vf,-c}; head[v] = etot++;",
            "    }",
            "",
            "    bool spfa() {",
            "        T inf = numeric_limits<T>::max() / 2;",
            "        fore(i,1,vtot) {",
            "            dis[i] = inf;",
            "            vis[i] = false;",
            "            pre[i] = -1;",
            "        }",
            "        dis[s] = 0;",
            "        vis[s] = true;",
            "        queue<int> q;",
            "        q.push(s);",
            "        while(q.size()) {",
            "            int u = q.front();",
            "            q.pop();",
            "            vis[u] = false;",
            "            for(int i=head[u];~i;i=e[i].nxt) {",
            "                int v = e[i].v;",
            "                if(e[i].f && dis[v] > dis[u] + e[i].c) {",
            "                    dis[v] = dis[u] + e[i].c;",
            "                    pre[v] = i;",
            "                    if(!vis[v]) {",
            "                        vis[v] = true;",
            "                        q.push(v);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dis[t] != inf;",
            "    }",
            "",
            "    void augment() {",
            "        int u = t;",
            "        T f = numeric_limits<T>::max();",
            "        while(~pre[u]) {",
            "            f = min(f,e[pre[u]].f);",
            "            u = e[pre[u]^1].v;",
            "        }",
            "        flow += f;",
            "        cost += f*dis[t];",
            "        u = t;",
            "        while(~pre[u]) {",
            "            e[pre[u]].f -= f;",
            "            e[pre[u]^1].f += f;",
            "            u = e[pre[u]^1].v;",
            "        }",
            "    }",
            "",
            "    pair<T,T> solve() {",
            "        flow = 0;",
            "        cost = 0;",
            "        while(spfa()) augment();",
            "        return {flow,cost};",
            "    }",
            "",
            "    void init(int s_,int t_,int vtot_) {",
            "        s = s_, t = t_, vtot = vtot_;",
            "        etot = 0;",
            "        fore(i,1,vtot) head[i] = -1;",
            "    }",
            "};",
            ""
        ],
        "description": "mcmf"
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "template<const ll T>",
            "struct ModInt {",
            "    const static ll mod = T;",
            "    ll x;",
            "    ModInt(ll x = 0) : x((x%mod+mod)%mod) {}",
            "    ll val() { return x; }",
            "    ModInt operator + (const ModInt &a) const { ll x0 = x + a.x; return ModInt(x0 < mod ? x0 : x0 - mod); }",
            "    ModInt operator - (const ModInt &a) const { ll x0 = x - a.x; return ModInt(x0 < 0 ? x0 + mod : x0); }",
            "    ModInt operator * (const ModInt &a) const { return ModInt(1LL * x * a.x % mod); }",
            "    ModInt operator / (const ModInt &a) const { return *this * a.inv(); }",
            "    bool operator == (const ModInt &a) const { return x == a.x; };",
            "    bool operator != (const ModInt &a) const { return x != a.x; };",
            "    void operator += (const ModInt &a) { x += a.x; if (x >= mod) x -= mod; }",
            "    void operator -= (const ModInt &a) { x -= a.x; if (x < 0) x += mod; }",
            "    void operator *= (const ModInt &a) { x = 1LL * x * a.x % mod; }",
            "    void operator /= (const ModInt &a) { *this = *this / a; }",
            "    friend ModInt operator + (ll y, const ModInt &a){ ll x0 = y + a.x; return ModInt(x0 < mod ? x0 : x0 - mod); }",
            "    friend ModInt operator - (ll y, const ModInt &a){ ll x0 = y - a.x; return ModInt(x0 < 0 ? x0 + mod : x0); }",
            "    friend ModInt operator * (ll y, const ModInt &a){ return ModInt(1LL * y * a.x % mod);}",
            "    friend ModInt operator / (ll y, const ModInt &a){ return ModInt(y) / a;}",
            "    friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.x;}",
            "    friend istream &operator>>(istream &is, ModInt &t){return is >> t.x;}",
            "",
            "    ModInt pow(int64_t n) const {",
            "        ModInt res(1), mul(x);",
            "        while(n){",
            "            if (n & 1) res *= mul;",
            "            mul *= mul;",
            "            n >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    ",
            "    ModInt inv() const {",
            "        ll a = x, b = mod, u = 1, v = 0;",
            "        while (b) {",
            "            ll t = a / b;",
            "            a -= t * b; swap(a, b);",
            "            u -= t * v; swap(u, v);",
            "        }",
            "        if (u < 0) u += mod;",
            "        return u;",
            "    }",
            "};",
            "using mint = ModInt<998244353>;",
            "// using mint = ModInt<1000000007>;",
            "// #define USE_C",
            "#ifdef USE_C",
            "    const int NC = 2e5+10;",
            "    mint f[NC],vf[NC];",
            "",
            "    auto init = []() {",
            "        f[0] = vf[0] = 1;",
            "        fore(i,1,NC-1) f[i] = f[i-1]*i;",
            "        vf[NC-1] = f[NC-1].inv();",
            "        for(int i=NC-2;i>=1;--i) vf[i] = vf[i+1]*(i+1);",
            "        return 0;",
            "    } ();",
            "",
            "    mint C(int x,int y) {",
            "        return f[x]*vf[y]*vf[x-y];",
            "    }",
            "#endif",
            ""
        ],
        "description": "mint"
    },
    "ntt": {
        "prefix": "ntt",
        "body": [
            "namespace NTT {",
            "    ll wl;",
            "    vi w;",
            "    ll qpow(ll x,ll y) {",
            "        ll res = 1;",
            "        while(y) {",
            "            if(y&1) res = res*x%mod;",
            "            x = x*x%mod;",
            "            y >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    void get(ll n) {",
            "        wl = 1;",
            "        while(wl<n) wl<<=1;",
            "    }",
            "    void init(ll n) {",
            "        ll t = 1;",
            "        while((1<<t) < n) t++;",
            "        t = min(t-1,21ll);",
            "        w.resize((1<<t)+1);",
            "        w[0] = 1;",
            "        w[1<<t] = qpow(31,1<<21-t);",
            "        for(ll i=t;i>=1;i--) w[1<<i-1] = w[1<<i]*w[1<<i] % mod;",
            "        for(ll i=1;i<(1<<t);i++) w[i] = w[i&i-1]*w[i&-i] % mod;",
            "    }",
            "    void DIF(vi &a) {",
            "        ll n = a.size();",
            "        for(ll mid=n>>1;mid>=1;mid>>=1) {",
            "            for(ll i=0,k=0;i<n;i+=mid<<1,k++) {",
            "                forn(j,mid) {",
            "                    ll x = a[i+j], y = a[i+j+mid]*w[k] % mod;",
            "                    a[i+j] = (x+y) % mod;",
            "                    a[i+j+mid] = (x-y+mod) % mod;",
            "                }",
            "            }",
            "        }",
            "    }",
            "    void DIT(vi &a) {",
            "        ll n = a.size();",
            "        for(ll mid=1;mid<n;mid<<=1) {",
            "            for(ll i=0,k=0;i<n;i+=mid<<1,k++) {",
            "                forn(j,mid) {",
            "                    ll x = a[i+j], y = a[i+j+mid];",
            "                    a[i+j] = (x+y) % mod;",
            "                    a[i+j+mid] = (x-y+mod)%mod*w[k]%mod;",
            "                }",
            "            }",
            "        }",
            "        ll inv = qpow(n,mod-2);",
            "        forn(i,n) a[i] = a[i]*inv % mod;",
            "        reverse(a.begin()+1,a.begin()+n);",
            "    }",
            "    vi mul(vi a,vi b) {",
            "        ll n = a.size(), m = b.size();",
            "        get(n+m);",
            "        a.resize(wl);",
            "        b.resize(wl);",
            "        DIF(a), DIF(b);",
            "        forn(i,wl) a[i] = a[i]*b[i] % mod;",
            "        DIT(a);",
            "        a.resize(n+m-1);",
            "        return a;",
            "    }",
            "}",
            ""
        ],
        "description": "ntt"
    },
    "persistent_array": {
        "prefix": "persistent_array",
        "body": [
            "template<typename T, int LOG>",
            "struct PersistentArray {",
            "    struct Node {",
            "        T data;",
            "        Node *child[1<<LOG] = {};",
            "        Node() {}",
            "        Node(const T &data): data(data) {}",
            "    };",
            "",
            "    Node *root;",
            "",
            "    PersistentArray(): root(nullptr) {}",
            "",
            "    T get(Node *t, int k) {",
            "        if(!k) return t->data;",
            "        return get(t->child[k&((1<<LOG)-1)],k>>LOG);",
            "    }",
            "",
            "    T get(const int &k) {",
            "        return get(root,k);",
            "    }",
            "",
            "    pair<Node*,T*> mutable_get(Node *t, int k) {",
            "        t = t ? new Node(*t) : new Node();",
            "        if(!k) return {t, &t->data};",
            "        auto p = mutable_get(t->child[k&((1<<LOG)-1)],k>>LOG);",
            "        t->child[k&((1<<LOG)-1)] = p.first;",
            "        return {t, p.second};",
            "    }",
            "",
            "    T* mutable_get(const int &k) {",
            "        auto ret = mutable_get(root,k);",
            "        root = ret.first;",
            "        return ret.second;",
            "    }",
            "",
            "    Node* build(Node *t, const T &data, int k) {",
            "        if(!t) t = new Node();",
            "        if(!k) {",
            "            t->data = data;",
            "            return t;",
            "        }",
            "        auto p = build(t->child[k&((1<<LOG)-1)],data,k>>LOG);",
            "        t->child[k&((1<<LOG)-1)] = p;",
            "        return t;",
            "    }",
            "",
            "    void build(const vector<T> &v) {",
            "        root = nullptr;",
            "        forn(i,v.size()) {",
            "            root = build(root,v[i],i+1);",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "persistent_array"
    },
    "persistent_seg": {
        "prefix": "persistent_seg",
        "body": [
            "int rt[N], cnt;",
            "int ls[N*60], rs[N*60], s[N*60];",
            "int L = -1e9, R = 1e9;",
            "",
            "void modify(int p,int q,int l,int r,int x,int v) {",
            "    if(l == r) s[q] = s[p] + v;",
            "    else {",
            "        int mid = l+r >> 1;",
            "        ls[q] = ls[p], rs[q] = rs[p];",
            "        if(x <= mid) {",
            "            ls[q] = ++cnt;",
            "            modify(ls[p],ls[q],l,mid,x,v);",
            "        } else {",
            "            rs[q] = ++cnt;",
            "            modify(rs[p],rs[q],mid+1,r,x,v);",
            "        }",
            "        s[q] = s[ls[q]] + s[rs[q]];",
            "    }",
            "}",
            ""
        ],
        "description": "persistent_seg"
    },
    "qpow": {
        "prefix": "qpow",
        "body": [
            "ll qpow(ll x,ll y) {",
            "    ll res = 1;",
            "    while(y) {",
            "        if(y&1) res = res*x%mod;",
            "        x = x*x%mod;",
            "        y >>= 1;",
            "    }",
            "    return res;",
            "}",
            ""
        ],
        "description": "qpow"
    },
    "read_edge": {
        "prefix": "red",
        "body": [
            "vii e(n+1);",
            "forn(i,n-1) {",
            "    int u,v;",
            "    io.r(u,v);",
            "    e[u].pb(v);",
            "    e[v].pb(u);",
            "}",
            ""
        ],
        "description": "read_edge"
    },
    "read_edge_weight": {
        "prefix": "rew",
        "body": [
            "vpi e(n+1);",
            "forn(i,n-1) {",
            "    int u,v,w;",
            "    io.r(u,v,w);",
            "    e[u].eb(v,w);",
            "    e[v].eb(u,w);",
            "}",
            ""
        ],
        "description": "read_edge_weight"
    },
    "rmq": {
        "prefix": "rmq",
        "body": [
            "template<typename T>",
            "struct RMQ {",
            "    using vt = vector<T>;",
            "    using vtt = vector<vt>;",
            "    using func_type = function<T(const T &, const T &)>;",
            "",
            "    int n,m;",
            "    vtt f;",
            "    func_type op;",
            "    ",
            "    static T default_func(const T &t1, const T &t2) {",
            "        return max(t1,t2);",
            "    }",
            "",
            "    RMQ(int n, func_type func) : n(n), m(__lg(n)), f(m+1, vt(n+1)), op(func) {}",
            "    RMQ(const vt &v, func_type func = default_func) : RMQ(int(v.size()), func) {",
            "        fore(i,1,n) f[0][i] = v[i-1];",
            "        fore(j,1,m)",
            "            for(int i=1;i+(1<<j)-1<=n;++i)",
            "                f[j][i] = op(f[j-1][i],f[j-1][i+(1<<(j-1))]);",
            "    }",
            "",
            "    T query(int l,int r){",
            "        int s = __lg(r-l+1);",
            "        return op(f[s][l],f[s][r-(1<<s)+1]);",
            "    }",
            "};",
            ""
        ],
        "description": "rmq"
    },
    "sa": {
        "prefix": "sa",
        "body": [
            "template<class T, class Cmp = less<T>>",
            "struct RMQ {",
            "    const Cmp cmp = Cmp();",
            "    static constexpr unsigned B = 64;",
            "    using u64 = unsigned long long;",
            "    int n;",
            "    vector<vector<T>> a;",
            "    vector<T> pre, suf, ini;",
            "    vector<u64> stk;",
            "",
            "    RMQ() {}",
            "    RMQ(const vector<T> &v) {",
            "        init(v);",
            "    }",
            "",
            "    void init(const vector<T> &v) {",
            "        n = v.size();",
            "        pre = suf = ini = v;",
            "        stk.resize(n);",
            "        if (!n) return;",
            "        const int M = (n-1)/B + 1;",
            "        const int lg = __lg(M);",
            "        a.assign(lg+1, vector<T>(M));",
            "        forn(i,M) {",
            "            a[0][i] = v[i*B];",
            "            for(int j=1;j<B && i*B+j<n;j++) {",
            "                a[0][i] = min(a[0][i], v[i*B+j], cmp);",
            "            }",
            "        }",
            "        fore(i,1,n-1) if(i%B) pre[i] = min(pre[i], pre[i - 1], cmp);",
            "        for(int i=n-2;i>=0;i--) if(i%B != B-1) suf[i] = min(suf[i], suf[i + 1], cmp);",
            "        forn(j,lg) {",
            "            for(int i=0;i+(2<<j)<=M;i++) {",
            "                a[j+1][i] = min(a[j][i], a[j][i+(1<<j)], cmp);",
            "            }",
            "        }",
            "        forn(i,M) {",
            "            const int l = i*B;",
            "            const int r = min(1U * n, l + B);",
            "            u64 s = 0;",
            "            fore(j,l,r-1) {",
            "                while(s && cmp(v[j], v[__lg(s) + l])) {",
            "                    s ^= 1ULL << __lg(s);",
            "                }",
            "                s |= 1ULL << (j - l);",
            "                stk[j] = s;",
            "            }",
            "        }",
            "    }",
            "",
            "    T operator()(int l, int r) {",
            "        if(l/B != (r-1)/B) {",
            "            T ans = min(suf[l], pre[r-1], cmp);",
            "            l = l/B+1;",
            "            r = r/B;",
            "            if(l<r) {",
            "                int k = __lg(r-l);",
            "                ans = min({ans, a[k][l], a[k][r-(1<<k)]}, cmp);",
            "            }",
            "            return ans;",
            "        } else {",
            "            int x = B*(l/B);",
            "            return ini[__builtin_ctzll(stk[r-1]>>(l-x))+l];",
            "        }",
            "    }    ",
            "};",
            "",
            "struct SA {",
            "    int n;",
            "    vi sa,rk,lc;",
            "    RMQ<int> rmq;",
            "",
            "    SA(string &s) {",
            "        n = s.size();",
            "        sa.resize(n);",
            "        lc.resize(n-1);",
            "        rk.resize(n);",
            "        iota(all(sa),0);",
            "        sort(all(sa),[&](int a,int b){return s[a]<s[b];});",
            "        rk[sa[0]] = 0;",
            "        fore(i,1,n-1) rk[sa[i]] = rk[sa[i-1]]+(s[sa[i]] != s[sa[i-1]]);",
            "        int k = 1;",
            "        vi tmp,cnt(n);",
            "        tmp.reserve(n);",
            "        while(rk[sa[n-1]] < n-1) {",
            "            tmp.clear();",
            "            forn(i,k) tmp.pb(n-k+i);",
            "            for(auto i: sa) if(i>=k) tmp.pb(i-k);",
            "            fill(all(cnt),0);",
            "            forn(i,n) cnt[rk[i]]++;",
            "            fore(i,1,n-1) cnt[i] += cnt[i-1];",
            "            for(int i=n-1;i>=0;--i) sa[--cnt[rk[tmp[i]]]] = tmp[i];",
            "            swap(rk,tmp);",
            "            rk[sa[0]] = 0;",
            "            fore(i,1,n-1) {",
            "                rk[sa[i]] = rk[sa[i-1]]+(tmp[sa[i-1]] < tmp[sa[i]] || sa[i-1]+k == n || tmp[sa[i-1]+k] < tmp[sa[i]+k]);",
            "            }",
            "            k *= 2;",
            "        }",
            "        for(int i=0,j=0;i<n;++i) {",
            "            if(!rk[i]) j = 0;",
            "            else {",
            "                for(j-=j>0;i+j<n && sa[rk[i]-1]+j<n && s[i+j]==s[sa[rk[i]-1]+j];) ++j;",
            "                lc[rk[i]-1] = j;",
            "            }",
            "        }",
            "        rmq.init(lc);",
            "    }",
            "",
            "    int lcp(int i,int j) {",
            "        i = rk[i], j = rk[j];",
            "        if(i>j) swap(i,j);",
            "        debug_assert(i != j);",
            "        return rmq(i,j);",
            "    }",
            "};",
            ""
        ],
        "description": "sa"
    },
    "sat": {
        "prefix": "sat",
        "body": [
            "struct SAT {",
            "    int n;",
            "    vii e;",
            "    vi ans;",
            "",
            "    SAT(int n): n(n),e(2*n+1),ans(n+1) {}",
            "",
            "    void add(int u,int a,int v,int b) {",
            "        e[u+(a^1)*n].pb(v+b*n);",
            "        e[v+(b^1)*n].pb(u+a*n);",
            "    }",
            "",
            "    bool solve() {",
            "        vi dfn(2*n+1),low(2*n+1),be(2*n+1),ins(2*n+1);",
            "        int idx = 0, cnt = 0;",
            "        stack<int> stk;",
            "        function<void(int)> dfs = [&](int u) {",
            "            dfn[u] = low[u] = ++idx;",
            "            ins[u] = 1;",
            "            stk.push(u);",
            "            for(auto v: e[u]) {",
            "                if(!dfn[v]) dfs(v);",
            "                if(ins[v]) low[u] = min(low[u],low[v]);",
            "            }",
            "            if(dfn[u] == low[u]) {",
            "                cnt++;",
            "                while(true) {",
            "                    int v = stk.top();",
            "                    stk.pop();",
            "                    ins[v] = 0;",
            "                    be[v] = cnt;",
            "                    if(v == u) break;",
            "                }",
            "            }",
            "        };",
            "        fore(i,1,2*n) if(!dfn[i]) dfs(i);",
            "        fore(i,1,n) {",
            "            if(be[i] == be[i+n]) return false;",
            "            ans[i] = be[i] > be[i+n];",
            "        }",
            "        return true;",
            "    }",
            "};",
            ""
        ],
        "description": "sat"
    },
    "scc": {
        "prefix": "scc",
        "body": [
            "struct SCC {",
            "    vii &e, scc;",
            "    vi dfn, low, be;",
            "    vector<bool> ins;",
            "    stack<int> stk;",
            "    int n, idx, cnt;",
            "",
            "    SCC(vii &e): e(e) {",
            "        n = (int)e.size()-1;",
            "        dfn.assign(n+1,0);",
            "        low.assign(n+1,0);",
            "        be.assign(n+1,0);",
            "        ins.assign(n+1,false);",
            "        scc.resize(n+1);",
            "        idx = cnt = 0;",
            "        fore(i,1,n) if(!dfn[i]) dfs(i);",
            "    }",
            "",
            "    void dfs(int u) {",
            "        dfn[u] = low[u] = ++idx;",
            "        ins[u] = true;",
            "        stk.push(u);",
            "        for(auto v: e[u]) {",
            "            if(!dfn[v]) dfs(v);",
            "            if(ins[v]) low[u] = min(low[u],low[v]);",
            "        }",
            "        if(dfn[u] == low[u]) {",
            "            cnt++;",
            "            while(true) {",
            "                int v = stk.top();",
            "                stk.pop();",
            "                ins[v] = false;",
            "                scc[cnt].pb(v);",
            "                be[v] = cnt;",
            "                if(v == u) break;",
            "            }",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "scc"
    },
    "seg": {
        "prefix": "seg",
        "body": [
            "struct Info {",
            "    $0",
            "};",
            "",
            "struct Tag {",
            "    ",
            "};",
            "",
            "Info operator+(const Info &a, const Info &b){",
            "    return {};",
            "}",
            "",
            "void apply(Info &x, Tag &a, Tag f) {",
            "    ",
            "}",
            "",
            "template<class Info, class Tag>",
            "struct LazySegmentTree {",
            "    int n;",
            "    vector<Info> info;",
            "    vector<Tag> tag;",
            "",
            "    LazySegmentTree() {}",
            "",
            "    LazySegmentTree(int n, Info _init = Info()) {",
            "        init(vector<Info>(n+1, _init));",
            "    }",
            "",
            "    LazySegmentTree(const vector<Info> &_init) {",
            "        init(_init);",
            "    }",
            "",
            "    void init(const vector<Info> &_init) {",
            "        n = (int)_init.size()-1;",
            "        info.assign((n<<2)+1, Info());",
            "        tag.assign((n<<2)+1, Tag());",
            "        function<void(int,int,int)> build = [&](int u,int l,int r) {",
            "            if(l == r) {",
            "                info[u] = _init[l];",
            "            } else {",
            "                int m = l+r >> 1;",
            "                build(u<<1,l,m), build(u<<1|1,m+1,r);",
            "                pull(u);",
            "            }",
            "        };",
            "        build(1,1,n);",
            "    }",
            "",
            "    void pull(int u) {",
            "        info[u] = info[u<<1] + info[u<<1|1];",
            "    }",
            "",
            "    void apply(int u, const Tag &v) {",
            "        ::apply(info[u], tag[u], v);",
            "    }",
            "",
            "    void push(int u) {",
            "        apply(u<<1,tag[u]);",
            "        apply(u<<1|1,tag[u]);",
            "        tag[u] = Tag();",
            "    }",
            "",
            "    void modify(int u,int l,int r,int x, const Info &v) {",
            "        if(l == r) {",
            "            info[u] = v;",
            "        } else {",
            "            int m = l+r >> 1;",
            "            push(u);",
            "            if(x<=m) modify(u<<1,l,m,x,v);",
            "            else modify(u<<1|1,m+1,r,x,v);",
            "            pull(u);",
            "        }",
            "    }",
            "",
            "    void modify(int x, const Info &v) {",
            "        modify(1,1,n,x,v);",
            "    }",
            "",
            "    Info query(int u,int l,int r,int x,int y) {",
            "        if(x<=l && r<=y) return info[u];",
            "        int m = l+r >> 1;",
            "        push(u);",
            "        if(y<=m) return query(u<<1,l,m,x,y);",
            "        if(x>m) return query(u<<1|1,m+1,r,x,y);",
            "        return query(u<<1,l,m,x,y) + query(u<<1|1,m+1,r,x,y);",
            "    }",
            "",
            "    Info query(int l,int r) {",
            "        return query(1,1,n,l,r);",
            "    }",
            "",
            "    void modify(int u,int l,int r,int x,int y, const Tag &v) {",
            "        if(l>y || r<x) return;",
            "        if(x<=l && r<=y) return apply(u,v);",
            "        int m = l+r >> 1;",
            "        push(u);",
            "        modify(u<<1,l,m,x,y,v);",
            "        modify(u<<1|1,m+1,r,x,y,v);",
            "        pull(u);",
            "    }",
            "",
            "    void modify(int l,int r, const Tag &v) {",
            "        modify(1,1,n,l,r,v);",
            "    }",
            "};",
            ""
        ],
        "description": "seg"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "vi minp, primes;",
            "",
            "void sieve(int n) {",
            "    minp.assign(n+1, 0);",
            "    fore(i,2,n) {",
            "        if(minp[i] == 0) {",
            "            minp[i] = i;",
            "            primes.pb(i);",
            "        }",
            "        for(auto p: primes) {",
            "            if(i*p > n) break;",
            "            minp[i*p] = p;",
            "            if(p == minp[i]) break;",
            "        }",
            "    }",
            "}",
            ""
        ],
        "description": "sieve"
    },
    "tarjan": {
        "prefix": "tarjan",
        "body": [
            "vi dfn(n+1),low(n+1),be(n+1),ins(n+1);",
            "int idx = 0, cnt = 0;",
            "stack<int> stk;",
            "function<void(int)> dfs = [&](int u) {",
            "    dfn[u] = low[u] = ++idx;",
            "    ins[u] = 1;",
            "    stk.push(u);",
            "    for(auto v: e[u]) {",
            "        if(!dfn[v]) dfs(v);",
            "        if(ins[v]) low[u] = min(low[u],low[v]);",
            "    }",
            "    if(dfn[u] == low[u]) {",
            "        cnt++;",
            "        while(true) {",
            "            int v = stk.top();",
            "            stk.pop();",
            "            ins[v] = 0;",
            "            be[v] = cnt;",
            "            if(v == u) break;",
            "        }",
            "    }",
            "};",
            "fore(i,1,n) if(!dfn[i]) dfs(i);",
            ""
        ],
        "description": "tarjan"
    },
    "template_cf": {
        "prefix": "cf",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#define forn(i, n) for (int i = 0; i < int(n); i++)",
            "#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)",
            "#define all(x) x.begin(),x.end()",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define fi first",
            "#define se second",
            "#define ve vector",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using pii = pair<int,int>;",
            "using vi = vector<int>;",
            "using vii = vector<vector<int>>;",
            "using vpi = vector<vector<pii>>;",
            "",
            "const int inf = 0x3f3f3f3f;",
            "const int mod = 998244353;",
            "const int N = 2e5+10;",
            "",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "#define FIO ",
            "struct IO { ",
            "    #ifdef FIO ",
            "        const static int BUFSIZE = 1 << 20; char buf[BUFSIZE], obuf[BUFSIZE], *p1, *p2, *pp; inline char getchar() { return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUFSIZE, stdin), p1 == p2) ? EOF : *p1++); } inline void putchar(char x) { ((pp - obuf == BUFSIZE && (fwrite(obuf, 1, BUFSIZE, stdout), pp = obuf)), *pp = x, pp++); } inline IO &flush() { fwrite(obuf, 1, pp - obuf, stdout); fflush(stdout); return *this; } IO() { p1 = buf, p2 = buf, pp = obuf; } ~IO() { flush(); } ",
            "    #else ",
            "        int (*getchar)() = &::getchar; int (*putchar)(int) = &::putchar; inline IO &flush() { fflush(stdout); return *this; }; ",
            "    #endif ",
            "        string sep = \" \"; int k = 2; template <typename T, typename std::enable_if<std::is_integral<T>::value || std::is_same<T, __int128_t>::value>::type * = nullptr> inline int r(T &s) { int f = 1; char ch = getchar(); s = 0; while (!isdigit(ch) && ch != EOF) f = (ch == '-' ? -1 : 1), ch = getchar(); while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar(); s *= f; return ch != EOF; } template <typename T> inline bool r(vector<T> &v) { bool f = true; for(auto &x: v) f &= r(x); return f; } template <typename T> inline bool rv(vector<T> &v, int x = 1) { bool f = true; for (int i = x; i < v.size(); ++i) f &= r(v[i]); return f; } template <typename T, typename enable_if<is_floating_point<T>::value>::type * = nullptr> inline int r(T &s) { int f = 1; char ch = getchar(); s = 0; while (!isdigit(ch) && ch != EOF && ch != '.') f = (ch == '-' ? -1 : 1), ch = getchar(); while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar(); if (ch == EOF) return false; if (ch == '.') { T eps = 0.1; ch = getchar(); while (isdigit(ch)) s = s + (ch ^ 48) * eps, ch = getchar(), eps /= 10; } s *= f; return ch != EOF; } inline int r(char &c) { char ch = getchar(); c = EOF; while (isspace(ch) && ch != EOF) ch = getchar(); if (ch != EOF) c = ch; return c != EOF; } inline int r(char *c) { char ch = getchar(), *s = c; while (isspace(ch) && ch != EOF) ch = getchar(); while (!isspace(ch) && ch != EOF) *(c++) = ch, ch = getchar(); *c = '\\0'; return s != c; } inline int r(string &s) { s.clear(); char ch = getchar(); while (isspace(ch) && ch != EOF) ch = getchar(); while (!isspace(ch) && ch != EOF) s += ch, ch = getchar(); return s.size() > 0; } inline int getline(char *c, const char &ed = '\\n') { char ch = getchar(), *s = c; while (ch != ed && ch != EOF) *(c++) = ch, ch = getchar(); *c = '\\0'; return s != c; } inline int getline(string &s, const char &ed = '\\n') { s.clear(); char ch = getchar(); while (ch != ed && ch != EOF) s += ch, ch = getchar(); return s.size() > 0; } template <typename T = int> inline T r() { T x; r(x); return x; } template <typename T, typename... Ts> int r(T &x, Ts &...val) { return r(x) && r(val...); } template <typename T, typename enable_if<is_integral<T>::value>::type * = nullptr> IO &w(T x) { if (x < 0) putchar('-'), x = -x; static char sta[20]; int top = 0; do sta[top++] = x % 10 + '0', x /= 10; while (x); while (top) putchar(sta[--top]); return *this; } inline IO &w(const string &str) { for (char ch : str) putchar(ch); return *this; } inline IO &w(const char *str) { while (*str != '\\0') putchar(*(str++)); return *this; } inline IO &w(char *str) { return w((const char *)str); } inline IO &w(const char &ch) { return putchar(ch), *this; } template <typename T, typename enable_if<is_floating_point<T>::value>::type * = nullptr> inline IO &w(T x) { if (x > 1e18 || x < -1e18) { w(\"[Floating point overflow]\"); throw; } if (x < 0) putchar('-'), x = -x; const static long long pow10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1000000000000000, 10000000000000000, 100000000000000000, 100000000000000000, 100000000000000000}; const auto &n = pow10[k]; long long whole = (int)x; double tmp = (x - whole) * n; long long frac = tmp; double diff = tmp - frac; if (diff > 0.5) { ++frac; if (frac >= n) frac = 0, ++whole; } else if (diff == 0.5 && ((frac == 0U) || (frac & 1U))) ++frac; w(whole); if (k == 0U) { diff = x - (double)whole; if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) ++whole; } else { putchar('.'); static char sta[20]; int count = k, top = 0; while (frac) { sta[top++] = frac % 10 + '0'; frac /= 10, count--; } while (count--) putchar('0'); while (top) putchar(sta[--top]); } return *this; } template <typename T> inline IO &w(vector<T> &v) { bool f = true; for(auto x: v) { if (f) f = false; else w(sep); w(x); }; return *this; } template <typename T> inline IO &wv(vector<T> &v,int x = 1) { bool f = true; for (int i = x; i < v.size(); ++i) { if (f) f = false; else w(sep); w(v[i]); }; wl(); return *this; } template <typename T, typename... Ts> inline IO &w(T x, Ts... val) { w(x); w(sep); w(val...); return *this; } template <typename... Ts> inline IO &wl(Ts... val) { w(val...); putchar('\\n'); return *this; } inline IO &wl(void) { putchar('\\n'); return *this; } template <typename T> inline IO &ww(T x, const string &s = \" \") { w(x), w(s); return *this; } inline IO &ss(const string &s) { return sep = s, *this; } inline IO &sp(const int &K) { return k = K, *this; } ",
            "} io;",
            "",
            "struct ER { ",
            "    #define debug(x...) cerr << \"Line \" << __LINE__ << \": \" #x \" = \"; er.wl(x) ",
            "    #define debug_assert(a, x...) if (not(a)) { cerr << \"Line \" << __LINE__ << \": Assertion `\" #a \"` failed.\" << endl; cerr << #x \" = \"; er.wl(x); exit(0);} ",
            "    string sep = \" \"; template <typename T, typename enable_if<is_integral<T>::value>::type * = nullptr> ER &w(T x) { cerr << x; return *this; } inline ER &w(const string &str) { cerr << str; return *this; } inline ER &w(const char *str) { cerr << str; return *this; } inline ER &w(char *str) { return w((const char *)str); } inline ER &w(const char &ch) { cerr << ch; return *this; } template <typename T, typename enable_if<is_floating_point<T>::value>::type * = nullptr> inline ER &w(T x) { cerr << x; return *this; } template <typename A, typename B> inline ER &w(pair<A, B> x) { cerr << \"(\"; w(x.fi); cerr << \", \"; w(x.se); cerr << \")\"; return *this; } template <typename T, size_t N> inline ER &w(array<T, N> &a) { cerr << \"[\"; bool first = true; for (auto &v : a) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"]\"; return *this; } template <typename T> inline ER &w(vector<T> &x) { cerr << \"[\"; bool first = true; for (auto &v : x) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"]\"; return *this; } template <typename T, class Cmp> inline ER &w(set<T, Cmp> &x) { cerr << \"{\"; bool first = true; for (auto &v : x) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"}\"; return *this; } template <typename T, class Cmp> inline ER &w(multiset<T, Cmp> &x) { cerr << \"{\"; bool first = true; for (auto &v : x) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"}\"; return *this; } template <typename A, typename B, class Cmp> inline ER &w(map<A, B, Cmp> &x) { cerr << \"{\"; bool first = true; for (auto &[a, b] : x) { cerr << (first ? \"\" : \", \"); w(a); cerr << \": \"; w(b); first = 0; } cerr << \"}\"; return *this; } template <typename T, typename... Ts> inline ER &w(T x, Ts... val) { w(x); w(sep); w(val...); return *this; } template <typename... Ts> inline ER &wl(Ts... val) { w(val...); cerr << endl; return *this; } inline ER &wl(void) { cerr << endl; return *this; } template <typename T> inline ER &ww(T x, const string &s = \" \") { w(x), w(s); return *this; } inline ER &ss(const string &s) { return sep = s, *this; } inline ER &sp(const int &K) { cerr << fixed << setprecision(K); return *this; } ",
            "} er;",
            "",
            "void solve(){",
            "    $0",
            "}",
            "",
            "int main() {",
            "    int tt;",
            "    io.r(tt);",
            "    while (tt--) {",
            "        solve();",
            "    }",
            "",
            "    return 0;",
            "}",
            ""
        ],
        "description": "template_cf"
    },
    "template_cpp": {
        "prefix": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "#define forn(i, n) for (int i = 0; i < int(n); i++)",
            "#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)",
            "#define all(x) x.begin(),x.end()",
            "#define pb push_back",
            "#define eb emplace_back",
            "#define fi first",
            "#define se second",
            "#define ve vector",
            "",
            "using namespace std;",
            "using ll = long long;",
            "using pii = pair<int,int>;",
            "using vi = vector<int>;",
            "using vii = vector<vector<int>>;",
            "using vpi = vector<vector<pii>>;",
            "",
            "const int inf = 0x3f3f3f3f;",
            "const int mod = 998244353;",
            "const int N = 2e5+10;",
            "",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "#define FIO ",
            "struct IO { ",
            "    #ifdef FIO ",
            "        const static int BUFSIZE = 1 << 20; char buf[BUFSIZE], obuf[BUFSIZE], *p1, *p2, *pp; inline char getchar() { return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUFSIZE, stdin), p1 == p2) ? EOF : *p1++); } inline void putchar(char x) { ((pp - obuf == BUFSIZE && (fwrite(obuf, 1, BUFSIZE, stdout), pp = obuf)), *pp = x, pp++); } inline IO &flush() { fwrite(obuf, 1, pp - obuf, stdout); fflush(stdout); return *this; } IO() { p1 = buf, p2 = buf, pp = obuf; } ~IO() { flush(); } ",
            "    #else ",
            "        int (*getchar)() = &::getchar; int (*putchar)(int) = &::putchar; inline IO &flush() { fflush(stdout); return *this; }; ",
            "    #endif ",
            "        string sep = \" \"; int k = 2; template <typename T, typename std::enable_if<std::is_integral<T>::value || std::is_same<T, __int128_t>::value>::type * = nullptr> inline int r(T &s) { int f = 1; char ch = getchar(); s = 0; while (!isdigit(ch) && ch != EOF) f = (ch == '-' ? -1 : 1), ch = getchar(); while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar(); s *= f; return ch != EOF; } template <typename T> inline bool r(vector<T> &v) { bool f = true; for(auto &x: v) f &= r(x); return f; } template <typename T> inline bool rv(vector<T> &v, int x = 1) { bool f = true; for (int i = x; i < v.size(); ++i) f &= r(v[i]); return f; } template <typename T, typename enable_if<is_floating_point<T>::value>::type * = nullptr> inline int r(T &s) { int f = 1; char ch = getchar(); s = 0; while (!isdigit(ch) && ch != EOF && ch != '.') f = (ch == '-' ? -1 : 1), ch = getchar(); while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar(); if (ch == EOF) return false; if (ch == '.') { T eps = 0.1; ch = getchar(); while (isdigit(ch)) s = s + (ch ^ 48) * eps, ch = getchar(), eps /= 10; } s *= f; return ch != EOF; } inline int r(char &c) { char ch = getchar(); c = EOF; while (isspace(ch) && ch != EOF) ch = getchar(); if (ch != EOF) c = ch; return c != EOF; } inline int r(char *c) { char ch = getchar(), *s = c; while (isspace(ch) && ch != EOF) ch = getchar(); while (!isspace(ch) && ch != EOF) *(c++) = ch, ch = getchar(); *c = '\\0'; return s != c; } inline int r(string &s) { s.clear(); char ch = getchar(); while (isspace(ch) && ch != EOF) ch = getchar(); while (!isspace(ch) && ch != EOF) s += ch, ch = getchar(); return s.size() > 0; } inline int getline(char *c, const char &ed = '\\n') { char ch = getchar(), *s = c; while (ch != ed && ch != EOF) *(c++) = ch, ch = getchar(); *c = '\\0'; return s != c; } inline int getline(string &s, const char &ed = '\\n') { s.clear(); char ch = getchar(); while (ch != ed && ch != EOF) s += ch, ch = getchar(); return s.size() > 0; } template <typename T = int> inline T r() { T x; r(x); return x; } template <typename T, typename... Ts> int r(T &x, Ts &...val) { return r(x) && r(val...); } template <typename T, typename enable_if<is_integral<T>::value>::type * = nullptr> IO &w(T x) { if (x < 0) putchar('-'), x = -x; static char sta[20]; int top = 0; do sta[top++] = x % 10 + '0', x /= 10; while (x); while (top) putchar(sta[--top]); return *this; } inline IO &w(const string &str) { for (char ch : str) putchar(ch); return *this; } inline IO &w(const char *str) { while (*str != '\\0') putchar(*(str++)); return *this; } inline IO &w(char *str) { return w((const char *)str); } inline IO &w(const char &ch) { return putchar(ch), *this; } template <typename T, typename enable_if<is_floating_point<T>::value>::type * = nullptr> inline IO &w(T x) { if (x > 1e18 || x < -1e18) { w(\"[Floating point overflow]\"); throw; } if (x < 0) putchar('-'), x = -x; const static long long pow10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1000000000000000, 10000000000000000, 100000000000000000, 100000000000000000, 100000000000000000}; const auto &n = pow10[k]; long long whole = (int)x; double tmp = (x - whole) * n; long long frac = tmp; double diff = tmp - frac; if (diff > 0.5) { ++frac; if (frac >= n) frac = 0, ++whole; } else if (diff == 0.5 && ((frac == 0U) || (frac & 1U))) ++frac; w(whole); if (k == 0U) { diff = x - (double)whole; if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) ++whole; } else { putchar('.'); static char sta[20]; int count = k, top = 0; while (frac) { sta[top++] = frac % 10 + '0'; frac /= 10, count--; } while (count--) putchar('0'); while (top) putchar(sta[--top]); } return *this; } template <typename T> inline IO &w(vector<T> &v) { bool f = true; for(auto x: v) { if (f) f = false; else w(sep); w(x); }; return *this; } template <typename T> inline IO &wv(vector<T> &v,int x = 1) { bool f = true; for (int i = x; i < v.size(); ++i) { if (f) f = false; else w(sep); w(v[i]); }; wl(); return *this; } template <typename T, typename... Ts> inline IO &w(T x, Ts... val) { w(x); w(sep); w(val...); return *this; } template <typename... Ts> inline IO &wl(Ts... val) { w(val...); putchar('\\n'); return *this; } inline IO &wl(void) { putchar('\\n'); return *this; } template <typename T> inline IO &ww(T x, const string &s = \" \") { w(x), w(s); return *this; } inline IO &ss(const string &s) { return sep = s, *this; } inline IO &sp(const int &K) { return k = K, *this; } ",
            "} io;",
            "",
            "struct ER { ",
            "    #define debug(x...) cerr << \"Line \" << __LINE__ << \": \" #x \" = \"; er.wl(x) ",
            "    #define debug_assert(a, x...) if (not(a)) { cerr << \"Line \" << __LINE__ << \": Assertion `\" #a \"` failed.\" << endl; cerr << #x \" = \"; er.wl(x); exit(0);} ",
            "    string sep = \" \"; template <typename T, typename enable_if<is_integral<T>::value>::type * = nullptr> ER &w(T x) { cerr << x; return *this; } inline ER &w(const string &str) { cerr << str; return *this; } inline ER &w(const char *str) { cerr << str; return *this; } inline ER &w(char *str) { return w((const char *)str); } inline ER &w(const char &ch) { cerr << ch; return *this; } template <typename T, typename enable_if<is_floating_point<T>::value>::type * = nullptr> inline ER &w(T x) { cerr << x; return *this; } template <typename A, typename B> inline ER &w(pair<A, B> x) { cerr << \"(\"; w(x.fi); cerr << \", \"; w(x.se); cerr << \")\"; return *this; } template <typename T, size_t N> inline ER &w(array<T, N> &a) { cerr << \"[\"; bool first = true; for (auto &v : a) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"]\"; return *this; } template <typename T> inline ER &w(vector<T> &x) { cerr << \"[\"; bool first = true; for (auto &v : x) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"]\"; return *this; } template <typename T, class Cmp> inline ER &w(set<T, Cmp> &x) { cerr << \"{\"; bool first = true; for (auto &v : x) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"}\"; return *this; } template <typename T, class Cmp> inline ER &w(multiset<T, Cmp> &x) { cerr << \"{\"; bool first = true; for (auto &v : x) { cerr << (first ? \"\" : \", \"); w(v); first = 0; } cerr << \"}\"; return *this; } template <typename A, typename B, class Cmp> inline ER &w(map<A, B, Cmp> &x) { cerr << \"{\"; bool first = true; for (auto &[a, b] : x) { cerr << (first ? \"\" : \", \"); w(a); cerr << \": \"; w(b); first = 0; } cerr << \"}\"; return *this; } template <typename T, typename... Ts> inline ER &w(T x, Ts... val) { w(x); w(sep); w(val...); return *this; } template <typename... Ts> inline ER &wl(Ts... val) { w(val...); cerr << endl; return *this; } inline ER &wl(void) { cerr << endl; return *this; } template <typename T> inline ER &ww(T x, const string &s = \" \") { w(x), w(s); return *this; } inline ER &ss(const string &s) { return sep = s, *this; } inline ER &sp(const int &K) { cerr << fixed << setprecision(K); return *this; } ",
            "} er;",
            "",
            "int main() {",
            "    $0",
            "",
            "    return 0;",
            "}",
            ""
        ],
        "description": "template_cpp"
    },
    "template_usaco": {
        "prefix": "usa",
        "body": [
            "auto setIO = [&](string s) { ",
            "    freopen((s+\".in\").c_str(),\"r\",stdin);",
            "    freopen((s+\".out\").c_str(),\"w\",stdout);",
            "};",
            "setIO(\"$0\");",
            ""
        ],
        "description": "template_usaco"
    },
    "var_mint": {
        "prefix": "var_mint",
        "body": [
            "namespace var_mint {",
            "    struct VarModular {",
            "        using value_type = int;",
            "    private:",
            "        static value_type P;",
            "    public:",
            "        value_type value;",
            "    ",
            "        VarModular(long long k = 0) : value(norm(k % P)) {}",
            "    ",
            "        friend VarModular& operator += (      VarModular& n, const VarModular& m) { n.value += m.value; if (n.value >= P) n.value -= P; return n; }",
            "        friend VarModular  operator +  (const VarModular& n, const VarModular& m) { VarModular r = n; return r += m; }",
            "    ",
            "        friend VarModular& operator -= (      VarModular& n, const VarModular& m) { n.value -= m.value; if (n.value < 0)    n.value += P; return n; }",
            "        friend VarModular  operator -  (const VarModular& n, const VarModular& m) { VarModular r = n; return r -= m; }",
            "        friend VarModular  operator -  (const VarModular& n)                      { return VarModular(-n.value); }",
            "    ",
            "        friend VarModular& operator *= (      VarModular& n, const VarModular& m) { n.value = reduce(n.value * 1ll * m.value); return n; }",
            "        friend VarModular  operator *  (const VarModular& n, const VarModular& m) { VarModular r = n; return r *= m; }",
            "    ",
            "        friend VarModular& operator /= (      VarModular& n, const VarModular& m) { return n *= m.inv(); }",
            "        friend VarModular  operator /  (const VarModular& n, const VarModular& m) { VarModular r = n; return r /= m; }",
            "    ",
            "        VarModular& operator ++ (   ) { return *this += 1; }",
            "        VarModular& operator -- (   ) { return *this -= 1; }",
            "        VarModular  operator ++ (int) { VarModular r = *this; *this += 1; return r; }",
            "        VarModular  operator -- (int) { VarModular r = *this; *this -= 1; return r; }",
            "    ",
            "        friend bool operator == (const VarModular& n, const VarModular& m) { return n.value == m.value; }",
            "        friend bool operator != (const VarModular& n, const VarModular& m) { return n.value != m.value; }",
            "    ",
            "        explicit    operator       int() const { return value; }",
            "        explicit    operator      bool() const { return value; }",
            "        explicit    operator long long() const { return value; }",
            "    ",
            "        static value_type           mod()      { return     P; }",
            "    ",
            "        value_type norm(long long k) {",
            "            if (k >= P) k -= P;",
            "            if (k < 0) k += P;",
            "            return k;",
            "        }",
            "    ",
            "        VarModular inv() const {",
            "            value_type a = value, b = P, x = 0, y = 1;",
            "            while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }",
            "            return VarModular(x);",
            "        }",
            "    ",
            "    private:",
            "        static uint64_t m;",
            "    public:",
            "        static void set_mod(value_type mod) {",
            "            m = (__uint128_t(1) << 64) / mod;",
            "            P = mod;",
            "        }",
            "    ",
            "        static value_type reduce(uint64_t a) {",
            "            uint64_t q = ((__uint128_t(m) * a) >> 64);",
            "            a -= q * P;",
            "            if (a >= P)",
            "                a -= P;",
            "            return a;",
            "        }",
            "    };",
            "    uint64_t VarModular::m = 0;",
            "    VarModular pow(VarModular m, long long p) {",
            "        VarModular r(1);",
            "        while (p) {",
            "            if (p & 1) r *= m;",
            "            m *= m;",
            "            p >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "    VarModular::value_type VarModular::P;",
            "    // use \"VarModular::set_mod([your value])\" later",
            "    ",
            "    ostream& operator << (ostream& o, const VarModular& m) { return o << m.value; }",
            "    istream& operator >> (istream& i,       VarModular& m) { long long k; i >> k; m.value = m.norm(k); return i; }",
            "    string   to_string(const VarModular& m) { return to_string(m.value); }",
            "    ",
            "    using mint = VarModular;",
            "    // using mint = long double;",
            "    ",
            "    vector<mint> fact, invfact;",
            "    void init_C(int n) {",
            "        fact.assign(n + 1, 1); invfact.assign(n + 1, 1);",
            "        for (int i = 2; i <= n; ++i) fact[i] = fact[i - 1] * i;",
            "        invfact.back() = mint(1) / fact.back();",
            "        for (int i = n - 1; i >= 0; --i) invfact[i] = invfact[i + 1] * (i + 1);",
            "    }",
            "    mint C(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        else return fact[n] * invfact[k] * invfact[n - k];",
            "    }",
            "}",
            "using namespace var_mint;",
            ""
        ],
        "description": "var_mint"
    },
    "virtue_tree": {
        "prefix": "vir",
        "body": [
            "vi a(n+1);",
            "io.rv(a);",
            "vii pos(n+1);",
            "fore(i,1,n) pos[a[i]].pb(i);",
            "HLD h(n);",
            "forn(i,n-1) {",
            "    int u,v;",
            "    io.r(u,v);",
            "    h.add(u,v);",
            "}",
            "h.work();",
            "vii e(n+1);",
            "vi st(n+1),dp(n+1);",
            "fore(i,1,n) {",
            "    if(pos[i].empty()) continue;",
            "    for(auto x: pos[i]) st[x] = 1;",
            "    auto [vs,es] = h.compress(pos[i]);",
            "    for(auto x: vs) e[x].clear(),dp[x] = 0; // clear info!",
            "    for(auto [u,v]: es) e[u].pb(v);",
            "    auto dfs = [&](auto&& dfs,int u) -> void {",
            "        for(auto v: e[u]) {",
            "            dfs(dfs,v);",
            "            $0",
            "        }",
            "    };",
            "    dfs(dfs,vs[0]);",
            "    for(auto x: pos[i]) st[x] = 0; ",
            "}",
            ""
        ],
        "description": "virtue_tree"
    },
    "WaveletMatrix": {
        "prefix": "WaveletMatrix",
        "body": [
            "struct WaveletMatrix {",
            "    struct BitRank {",
            "        vector<long long> block;",
            "        vector<int> count;",
            "        BitRank() {}",
            "        void resize(int num) {",
            "            block.resize(((num + 1) >> 6) + 1, 0);",
            "            count.resize(block.size(), 0);",
            "        }",
            "        void set(int i, long long val) {",
            "            block[i >> 6] |= (val << (i & 63));",
            "        }",
            "        void build() {",
            "            for (int i = 1; i < block.size(); i++) {",
            "            count[i] = count[i - 1] + __builtin_popcountll(block[i - 1]);",
            "            }",
            "        }",
            "        int rank1(int i) {",
            "            return count[i >> 6] +",
            "                __builtin_popcountll(block[i >> 6] & ((1ULL << (i & 63)) - 1ULL));",
            "        }",
            "        int rank1(int i, int j) {",
            "            return rank1(j) - rank1(i);",
            "        }",
            "        int rank0(int i) { return i - rank1(i); }",
            "        int rank0(int i, int j) {",
            "            return rank0(j) - rank0(i);",
            "        }",
            "    };",
            "    ",
            "    int height;",
            "    vector<BitRank> B;",
            "    vector<int> pos;",
            "",
            "    WaveletMatrix() {}",
            "    WaveletMatrix(vector<int> vec): WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}",
            "    // sigma: 字母表大小(字符串的话)，数字序列的话是数的种类",
            "    WaveletMatrix(vector<int> vec, int sigma) {",
            "        init(vec, sigma);",
            "    }",
            "    void init(vector<int>& vec, int sigma) {",
            "        height = (sigma == 1) ? 1 : (64 - __builtin_clzll(sigma - 1));",
            "        B.resize(height), pos.resize(height);",
            "        for (int i = 0; i < height; ++i) {",
            "            B[i].resize(vec.size());",
            "            for (int j = 0; j < vec.size(); ++j) {",
            "                B[i].set(j, get(vec[j], height - i - 1));",
            "            }",
            "            B[i].build();",
            "            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {",
            "                return !get(c, height - i - 1);",
            "            });",
            "            pos[i] = it - vec.begin();",
            "        }",
            "    }",
            "    int get(int val, int i) { return val >> i & 1; }",
            "",
            "    // [l, r] 中val出现的频率 (1-base)",
            "    int query(int l, int r, int val) {",
            "        return l == 1 ? query(val, r) : query(val, r) - query(val, l-1);",
            "    }",
            "    // [1, i] 中val出现的频率",
            "    int query(int val, int i) {",
            "        int p = 0;",
            "        for (int j = 0; j < height; ++j) {",
            "            if (get(val, height - j - 1)) {",
            "                p = pos[j] + B[j].rank1(p);",
            "                i = pos[j] + B[j].rank1(i);",
            "            } else {",
            "                p = B[j].rank0(p);",
            "                i = B[j].rank0(i);",
            "            }",
            "        }",
            "        return i - p;",
            "    }",
            "    // [l, r] 中k小",
            "    int kth(int l, int r, int k) {",
            "        l--;",
            "        int res = 0;",
            "        for (int i = 0; i < height; ++i) {",
            "            int j = B[i].rank0(l, r);",
            "            if (j >= k) {",
            "                l = B[i].rank0(l);",
            "                r = B[i].rank0(r);",
            "            } else {",
            "                l = pos[i] + B[i].rank1(l);",
            "                r = pos[i] + B[i].rank1(r);",
            "                k -= j;",
            "                res |= (1 << (height - i - 1));",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "    int query(int i, int j, int a, int b, int l, int r, int x) {",
            "        if (i == j || r <= a || b <= l) return 0;",
            "        if (a <= l && r <= b) return j - i;",
            "        int mid = (l + r) >> 1;",
            "        int left = query(B[x].rank0(i), B[x].rank0(j), a, b, l, mid, x + 1);",
            "        int right = query(pos[x] + B[x].rank1(i), pos[x] + B[x].rank1(j), a, b, mid, r, x + 1);",
            "        return left + right;",
            "    }",
            "    // [l, r] 在 [a, b] 值域的数字个数",
            "    int query(int l, int r, int a, int b) {",
            "        return query(l-1, r, a, b+1, 0, 1 << height, 0);",
            "    }",
            "    int rangemin(int i, int j, int a, int b, int l, int r, int x, int val) {",
            "        if (i == j || r <= a || b <= l) return -1;",
            "        if (r - l == 1) return val;",
            "        int mid = (l + r) >> 1;",
            "        int res = rangemin(B[x].rank0(i), B[x].rank0(j), a, b, l, mid, x + 1, val);",
            "        if (res < 0) return rangemin(pos[x] + B[x].rank1(i), pos[x] + B[x].rank1(j), a, b, mid, r, x + 1, val + (1 << (height - x - 1)));",
            "        else return res;",
            "    }",
            "    // [l, r] 在 [a, b] 值域内存在的最小值是什么，不存在返回-1",
            "    int rangemin(int l, int r, int a, int b) {",
            "        return rangemin(l-1, r, a, b+1, 0, 1 << height, 0, 0);",
            "    }",
            "};",
            ""
        ],
        "description": "WaveletMatrix"
    },
}